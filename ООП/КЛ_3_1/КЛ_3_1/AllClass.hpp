/*
 Проверка готовности объектов к работе


 Фрагмент методического указания.
 Создание объектов и построение исходного иерархического дерева объектов.
 Система собирается из объектов, принадлежащих определенным классам. В тексте постановки задачи классу соответствует уникальный номер. Относительно номера класса определяются требования (свойства, функциональность).
 Первоначальная сборка системы (дерева иерархии объектов, программы) осуществляется исходя из входных данных. Данные вводятся построчно.


 Первая строка содержит имя корневого объекта (объект приложение). Номер класса корневого объекта 1. Корневой объект объявляется в основной программе (main). Исходное состояние корневого объекта соответствует его функционированию.
 Далее, каждая строка входных данных определяет очередной объект, задает его характеристики и расположение на дереве иерархии.
 Структура данных в строке:
 «Наименование головного объекта» «Наименование очередного объекта» «Номер класса принадлежности очередного объекта» «Номер исходного состояния очередного объекта»


 Ввод иерархического дерева завершается, если наименование головного объекта равно «endtree» (в данной строке ввода больше ничего не указывается).


 Готовность объекта характеризуется значением его состояния. Значение состояния - целое число.
 Определены правила для значения состояния:
     0 – объект выключен;
     Отрицательное – объект включен, но не функционирует, обнаружена неисправность. Значение классифицирует характер неисправности.
    Положительное – объект включен, функционирует в штатном режиме. Значение определяет текущее состояние объекта.


 Подчиненные объекты располагаются слева на право относительно головного, согласно их следованию в исходных данных. Исходные данные подготовлены таким образом, что любой головной объект предварительно добавлен в качестве подчиненного. Подразумевается, что все объекты имеют уникальные имена.
 Для организации исходя из входных данных создания экземпляров объектов и формирования иерархического дерева, необходимо:
 1.      В базовом классе реализовать метод поиска объекта на дереве объектов по его наименованию и возврата указателя на него. Если объект не найден, то вернуть нулевой указатель.
 2.      В корневом объекте (объект приложения) реализовать метод чтения исходных данных, создания объектов и построения исходного дерева иерархии.

==============================================
 Пример


 Ввод
 
 app_root
 app_root object_1 3 1
 app_root object_2 2 1
 object_2 object_4 3 -1
 object_2 object_5 3 1
 app_root object_3 3 1
 object_2 object_6 2 1
 object_1 object_7 2 1
 endtree
 
 Вывод списка готовности объектов

 The object app_root is ready
 The object object_1 is ready
 The object object_7 is ready
 The object object_2 is ready
 The object object_4 is not ready
 The object object_5 is ready
 The object object_6 is ready
 The object object_3 is ready
 
 =============================================
 В результате решения задачи опроса готовности объектов, относительно каждого объекта системы на консоль надо вывести соответствующую информацию:
 Если свойство определяющее готовность объекта имеет положительное значение:
 The object «наименование объекта» is ready
 иначе
 The object «наименование объекта» is not ready
 Система содержит объекты трех классов, не считая корневого. Номера классов: 2,3,4.
 */

#ifndef AllClass_hpp
#define AllClass_hpp

#include <vector>
#include <string>
using namespace std;


class BasicClass {
private:
    string name;
    int state;
    BasicClass* parent;
    vector <BasicClass*> children;
    vector <BasicClass*>::iterator children_iterator;
public:
    BasicClass(BasicClass*, int, string = "base");
    void setName(string);
    string getName();
    void setParent(BasicClass*);
    BasicClass* find(string);
    void setState(int);
    int getState();
    void printState();
};

class Class2 : public BasicClass {
public:
    Class2(BasicClass*,int, string);
};

class Class3 : public BasicClass {
public:
    Class3(BasicClass*,int, string);
};

class Class4 : public BasicClass {
public:
    Class4(BasicClass*,int, string);
};

class Application : public BasicClass {
private:
    BasicClass* temp_parent;
    BasicClass* temp_child;
    BasicClass* root_parent;
public:
    Application(BasicClass* parent = 0,int state=1 );
    Application(BasicClass* parent,int state,string name);
    void buildTree();
    int execute();
};


#endif /* AllClass_hpp */
